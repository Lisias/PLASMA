include "inc/cmdsys.plh"
include "inc/args.plh"
include "inc/fileio.plh"

struc t_header
    word magic[2]
    byte FLG
    byte BD
end
word arg
byte ref

def dump(addr, len)#0
    while len
        putc(^addr == $0A ?? $0D :: ^addr)
        addr++
        len--
    loop
end
def lz4Decomp(seq, seqend)#2
    word buff, data, len, offset, fill
    byte token

    buff = heapalloc(heapavail - 256)
    data = buff
    if not buff
        return NULL, 0
    fin
    while seq < seqend
        //puts("LZ4 sequence @ $"); puth(seq); putln
        token = ^seq
        seq++
        len = token >> 4
        if len
            //
            // Literal sequence
            //
            if len == 15
                while ^seq == 255
                    len = len + 255
                    seq++
                loop
                len = len + ^seq
                seq++
            fin
            //puts("Literals @ $"); puth(seq); puts(", len $"); puth(len); putln; getc
            dump(seq, len)
            memcpy(data, seq, len)
            data = data + len
            seq  = seq + len
        fin
        //
        // Match sequence
        //
        offset = *seq
        seq    = seq + 2
        len    = (token & $0F) + 4
        if len == 19 // $0F + 4
            while ^seq == 255
                len = len + 255
                seq++
            loop
            len = len + ^seq
            seq++
        fin
        //puts("Match offset $"); puth(offset); puts(" @ $"); puth(data - offset); puts(", len $"); puth(len); putln; getc
        while len > offset
            memcpy(data, data - offset, offset)
            dump(data, offset)
            data = data + offset
            len  = len - offset
        loop
        memcpy(data, data - offset, len)
        dump(data, len)
        data = data + len
    loop
    return buff, data - buff
end

def lz4ReadBlock(flags)#2
    word size[2], block, data, len
    
    fileio:read(ref, @size, 4)
    if size[1] & $7FFF
        return NULL, 0
    fin
    block = heapalloc(size[0])
    if block
        fileio:read(ref, block, size[0])
    else
        return NULL, 0
    fin
    if size[1] & $8000
        //
        // Uncompressed block
        //
        data = block
        //puts("Uncompressed data @ $"); puth(data); putln
    else
        //
        // Decompress block
        //
        //puts("Compressed block @ $"); puth(block); putln
        data, len = lz4Decomp(block, block + size[0])
        //puts("Uncompressed data @ $"); puth(data); putln
        if data
            memcpy(block, data, len)
            data = block
        fin
        heaprelease(block + len)
    fin
    if flags & $10 // Block Checksum
        fileio:read(ref, @size, 4)
    fin
    return data, len
end

def lz4ReadFrame#0
    word data, len
    byte header[t_header], opt

    fileio:read(ref, @header, t_header)
    if header:magic[1] <> $184D or header:magic[0] <> $2204
        puts("Not LZ4 file.\n")
        return
    fin
    if header.FLG & $C0 <> $40
        puts("Wrong LZ4 version.\n")
        return
    fin
    if header.BD & $70 <> $40
        puts("Not 64K block size.\n")
        return
    fin
    opt = 1
    if header.FLG & $08 // Content Size
        opt = opt + 8
    fin
    if header.FLG & $01 // Dictionary ID
        opt = opt + 4
    fin
    fileio:read(ref, heapmark, opt) // Read rest of header and throw away
    repeat
        data, len = lz4ReadBlock(header.FLG)
    until not data
    if header.FLG & $04 // Content Checksun
        fileio:read(ref, heapmark, 4)
    fin
end
arg = argNext(argFirst)
if ^arg
    ref = fileio:open(arg)
    if ref
        lz4ReadFrame
        fileio:close(ref)
    else
        puts("File not found.\n")
    fin
fin

done
