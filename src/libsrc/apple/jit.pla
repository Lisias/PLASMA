//
// PLASMA JIT bytecode compiler
//
include "inc/cmdsys.plh"
//
// Module don't free memory
//
const modkeep     = $2000
const modinitkeep = $4000
//
// Indirect interpreter DEFinition entrypoint
//
struc t_defentry
    byte interpjsr
    word interpaddr
    word bytecodeaddr
    byte callcount
    byte bytecodesize
end
//
// JIT compiler constants
//
const jitcount    = $10
const jitcomp     = $03E2
const jitcodeptr  = $03E4
const codemax     = $BEE0
//
// AUX bytecode interpreter entrypoint
//
const interpentry = $03DC
//
// TOS caching values
//
const TOSL_DIRTY = 1
const TOSL_CLEAN = 2
//
// Resolve virtual X with real X
//
def resolveX(codeptr, VX)#2
    while VX > 0
        ^codeptr = $E8; codeptr++ // INX
        VX--
    loop
    while VX < 0
        ^codeptr = $CA; codeptr++ // DEX
        VX++
    loop
    return codeptr, 0
end
//
// JIT compiler entry
//
def compiler(defptr)#0
    word codeptr, isdata, addrxlate, bytecode, i, case, dest, VX
    byte opcode, j, A_IS_TOSL
    
    //puts("JIT compiler invoked for :$"); puth(defptr=>bytecodeaddr); putln
    if isult(heapavail, 512 + defptr->bytecodesize) // 256 * sizeof(word) address xlate
        //
        // Not enough heap available
        //
        defptr=>interpaddr = interpentry
        return
    fin
    addrxlate = heapmark
    memset(addrxlate, 0, 512) // Clear xlate buffer
    //
    // Copy bytecode def from AUX to heap for compiling
    //
    bytecode = addrxlate + 512 // def bytecode
    *$003C   = defptr=>bytecodeaddr
    *$003E   = *$003C + defptr->bytecodesize
    *$0042   = bytecode
    call($C311, 0, 0, 0, $00) // CALL XMOVE with carry clear (AUX->MAIN)
    //^$C053 // MIX TEXT
    //puts("Addr Xlate: $"); puth(addrxlate); putln
    //puts("Bytecode:   $"); puth(bytecode); putln
    //
    // Find all branch targets and optimization fences. Tag the opcode with the LSB set
    //
    // All PLASMA ops are even (LSB clear), so this will flag when to fence optimizations
    // During compiling.
    //
    isdata = addrxlate // Use this buffer
    i = 0
    while i <= defptr->bytecodesize
        if not isdata->[i]
            when (^(bytecode+i) & $FE)
                //
                // Multi-byte operands
                //
                is $2E // CS
                    i = i + ^(bytecode+i+1) + 1
                    break
                //
                // Double byte operands
                //
                is $26 // LA
                is $2C // CW
                is $54 // CALL
                is $58 // ENTER
                is $68 // LAB
                is $6A // LAW
                is $78 // SAB
                is $7A // SAW
                is $7C // DAB
                is $7E // DAW
                is $B4 // ADDAB
                is $B6 // ADDAW
                is $BC // IDXAB
                is $BE // IDXAW
                    i++
                //
                // Single byte operands
                //
                is $2A // CB
                is $28 // LLA
                is $38 // ADDI
                is $3A // SUBI
                is $3C // ANDI
                is $3E // ORI
                is $5A // LEAVE
                is $5E // CFFB
                is $64 // LLB
                is $66 // LLW
                is $6C // DLB
                is $6E // DLW
                is $74 // SLB
                is $76 // SLW
                is $B0 // ADDLB
                is $B2 // ADDLW
                is $B8 // IDXLB
                is $BA // IDXLW
                    i++
                    break
                //
                // Branches
                //
                is $50 // BRNCH
                is $22 // BREQ
                is $24 // BENE
                is $4C // BRFLS
                is $4E // BRTRU
                is $A0 // BRGT
                is $A2 // BRLT
                is $A4 // INCBRLE
                is $A6 // ADDBRLE
                is $A8 // DECBRGE
                is $AA // SUBBRGE
                is $AC // BRAND
                is $AE // BROR
                    i++
                    //
                    // Flag branch destination
                    //
                    dest = i + *(bytecode+i)
                    ^(bytecode+dest) = ^(bytecode+dest) | 1
                    i++
                    break
                //
                // SELect/caseblock
                //
                is $52 // SEL
                    i++
                    case = i + *(bytecode+i)
                    i++
                    isdata->[case] = 1 // Flag as data
                    j = ^(bytecode+case)
                    case++
                    repeat
                        isdata->[case] = 1 // Flag as data
                        case++
                        isdata->[case] = 1 // Flag as data
                        case++
                        dest = case + *(bytecode+case)
                        ^(bytecode+dest) = ^(bytecode+dest) | 1 // Flag as branch dest
                        isdata->[case] = 1 // Flag as data
                        case++
                        isdata->[case] = 1 // Flag as data
                        case++
                        j--
                    until not j
                    break
            wend
        fin
        i++
    loop
    memset(isdata, 0, 256) // Clear part of xlate buffer used for isdata
    //
    // Compile the bytecodes
    //
    codeptr   = *jitcodeptr
    VX        = 0 // Virtual X register
    A_IS_TOSL = FALSE
    i         = 0
    if ^bytecode == $58
        //puts("ENTER "); puti(^(bytecode+1)); //putc(',');puti(^(bytecode+2))
        //
        // Call into VM
        //
        ^codeptr = $20;  codeptr++ // JSR INTERP
        *codeptr = $3D0; codeptr = codeptr + 2
        ^codeptr = $58;  codeptr++ // ENTER CODE
        ^codeptr = ^(bytecode+1); codeptr++ // ENTER FRAME SIZE
        ^codeptr = ^(bytecode+2); codeptr++ // ENTER ARG COUNT
        ^codeptr = $C0; codeptr++ // NATV CODE
        i = 3
    fin
    //
    // First optimization is to keep zero in Y register at all times
    //
    ^codeptr = $A0; codeptr++ // LDY #imm
    ^codeptr = $00; codeptr++ // $00
    while isule(codeptr, codemax)
        //putc('$'); puth(codeptr); //putc(':')
        //putc('['); puti(i); //puts("] ")
        opcode = ^(bytecode+i)
        if opcode & 1
            //
            // Optimization fence
            //
            if A_IS_TOSL & TOSL_DIRTY
                ^codeptr = $95;    codeptr++ // STA zp,X
                ^codeptr = $D0+VX; codeptr++ // ESTKL
                A_IS_TOSL = FALSE
            fin
            codeptr, VX = resolveX(codeptr, VX)
            opcode = opcode & $FE
        fin
        //
        // Update bytecode->native code address translation
        //
        if addrxlate=>[i]
            //
            // Address list awaiting resolution
            //
            dest = addrxlate=>[i] + *jitcodeptr
            repeat
                case  = *dest
                *dest = codeptr
                dest  = case + *jitcodeptr
            until not case
        fin
        addrxlate=>[i] = codeptr
        if opcode < $20
            // CN,CN,CN,CN,CN,CN,CN,CN                                 ; 00 02 04 06 08 0A 0C 0E
            // CN,CN,CN,CN,CN,CN,CN,CN                                 ; 10 12 14 16 18 1A 1C 1E
            //puts("CN $"); putb(^(bytecode+i)/2)
            if A_IS_TOSL & TOSL_DIRTY
                ^codeptr = $95;    codeptr++ // STA zp,X
                ^codeptr = $D0+VX; codeptr++ // ESTKL
            fin
            VX-- //^codeptr = $CA;    codeptr++ // DEX
            if ^(bytecode+i) == 0
                ^codeptr = $98;    codeptr++ // TYA -> LDA #$00
            else
                ^codeptr = $A9;    codeptr++ // LDA #imm
                ^codeptr = ^(bytecode+i)/2; codeptr++
            fin
            ^codeptr = $94;    codeptr++ // STY zp,X
            ^codeptr = $C0+VX; codeptr++ // ESTKH
            //^codeptr = $95;    codeptr++ // STA zp,X
            //^codeptr = $D0+VX; codeptr++ // ESTKL
            A_IS_TOSL = TOSL_DIRTY
        else
            when opcode
                // MINUS1,BREQ,BRNE,LA,LLA,CB,CW,CS                        ; 20 22 24 26 28 2A 2C 2E
                is $20
                    //puts("MINUS_ONE")
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    VX-- //^codeptr = $CA;    codeptr++ // DEX
                    ^codeptr = $A9;    codeptr++ // LDA #imm
                    ^codeptr = $FF;    codeptr++ // $FF
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    break
                is $22
                    i++
                    dest = i + *(bytecode+i)
                    i++
                    //puts("BREQ "); puti(dest)
                    //^codeptr = $E8;      codeptr++ // INX
                    //^codeptr = $E8;      codeptr++ // INX
                    codeptr, VX = resolveX(codeptr, VX + 2)
                    if not A_IS_TOSL
                        ^codeptr = $B5;      codeptr++ // LDA zp,X
                        ^codeptr = $D0-2+VX; codeptr++ // ESTKL-2
                    fin
                    ^codeptr = $D5;      codeptr++ // CMP zp,X
                    ^codeptr = $D0-1+VX; codeptr++ // ESTKL-1
                    ^codeptr = $D0;      codeptr++ // BNE rel
                    ^codeptr = $09;      codeptr++ // +9
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0-2+VX; codeptr++ // ESTKH-2
                    ^codeptr = $D5;      codeptr++ // CMP zp,X
                    ^codeptr = $C0-1+VX; codeptr++ // ESTKH-1
                    ^codeptr = $D0;      codeptr++ // BNE rel
                    ^codeptr = $03;      codeptr++ // +3
                    ^codeptr = $4C;      codeptr++ // JMP abs
                    *codeptr = addrxlate=>[dest]
                    if not (*codeptr & $8000) // Unresolved address list
                        addrxlate=>[dest] = codeptr - *jitcodeptr
                    fin
                    codeptr  = codeptr + 2
                    A_IS_TOSL = FALSE
                    break
                is $24
                    i++
                    dest = i + *(bytecode+i)
                    i++
                    //puts("BRNE "); puti(dest)
                    //^codeptr = $E8;      codeptr++ // INX
                    //^codeptr = $E8;      codeptr++ // INX
                    codeptr, VX = resolveX(codeptr, VX + 2)
                    if not A_IS_TOSL
                        ^codeptr = $B5;      codeptr++ // LDA zp,X
                        ^codeptr = $D0-2+VX; codeptr++ // ESTKL-2
                    fin
                    ^codeptr = $D5;      codeptr++ // CMP zp,X
                    ^codeptr = $D0-1+VX; codeptr++ // ESTKL-1
                    ^codeptr = $D0;      codeptr++ // BNE rel
                    ^codeptr = $06;      codeptr++ // +6
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0-2+VX; codeptr++ // ESTKH-2
                    ^codeptr = $D5;      codeptr++ // CMP zp,X
                    ^codeptr = $C0-1+VX; codeptr++ // ESTKH-1
                    ^codeptr = $F0;      codeptr++ // BEQ rel
                    ^codeptr = $03;      codeptr++ // +3
                    ^codeptr = $4C;      codeptr++ // JMP abs
                    *codeptr = addrxlate=>[dest]
                    if not (*codeptr & $8000) // Unresolved address list
                        addrxlate=>[dest] = codeptr - *jitcodeptr
                    fin
                    codeptr  = codeptr + 2
                    A_IS_TOSL = FALSE
                    break
                is $26
                    i++
                    //puts("LA $"); puth(*(bytecode+i))
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    VX-- //^codeptr = $CA;    codeptr++ // DEX
                    ^codeptr = $A9;    codeptr++ // LDA #imm
                    ^codeptr = ^(bytecode+i+1); codeptr++
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $A9;    codeptr++ // LDA #imm
                    ^codeptr = ^(bytecode+i); codeptr++
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    i++
                    break
                is $28
                    i++
                    //puts("LLA "); puti(^(bytecode+i))
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    VX-- //^codeptr = $CA;    codeptr++ // DEX
                    if ^(bytecode+i) == 0
                        ^codeptr = $98;    codeptr++ // TYA -> LDA #$00
                    else
                        ^codeptr = $A9;    codeptr++ // LDA #imm
                        ^codeptr = ^(bytecode+i); codeptr++
                    fin
                    ^codeptr = $18;    codeptr++ // CLC
                    ^codeptr = $65;    codeptr++ // ADC zp
                    ^codeptr = $E0;    codeptr++ // IFPL
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $D0+VX; codeptr++ // ESTKL
                    ^codeptr = $98;    codeptr++ // TYA -> LDA #$00
                    ^codeptr = $65;    codeptr++ // ADC zp
                    ^codeptr = $E1;    codeptr++ // IFPH
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    A_IS_TOSL = FALSE
                    break
                is $2A
                    i++
                    //puts("CB $"); putb(^(bytecode+i))
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    VX-- //^codeptr = $CA;    codeptr++ // DEX
                    ^codeptr = $A9;    codeptr++ // LDA #imm
                    ^codeptr = ^(bytecode+i); codeptr++
                    ^codeptr = $94;    codeptr++ // STY zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    break
                is $2C
                    i++
                    //puts("CW $"); puth(*(bytecode+i))
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    VX-- //^codeptr = $CA;    codeptr++ // DEX
                    ^codeptr = $A9;    codeptr++ // LDA #imm
                    ^codeptr = ^(bytecode+i+1); codeptr++
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    if ^(bytecode+i) == 0
                        ^codeptr = $98;    codeptr++ // TYA -> LDA #$00
                    else
                        ^codeptr = $A9;    codeptr++ // LDA #imm
                        ^codeptr = ^(bytecode+i); codeptr++
                    fin
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    i++
                    break
                is $2E
                    i++
                    j    = ^(bytecode+i)
                    dest = i + j + 1
                    //puts("CS "); //puts(bytecode+i); //puts("-->"); puti(dest)
                    if isule(codeptr + 12 + j, codemax)
                        if A_IS_TOSL & TOSL_DIRTY
                            ^codeptr = $95;    codeptr++ // STA zp,X
                            ^codeptr = $D0+VX; codeptr++ // ESTKL
                        fin
                        VX-- //^codeptr = $CA;    codeptr++ // DEX
                        ^codeptr = $A9;    codeptr++ // LDA #imm
                        ^codeptr = codeptr+10; codeptr++
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                        ^codeptr = $A9;    codeptr++ // LDA #imm
                        ^codeptr = (codeptr+6)>>8; codeptr++
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $C0+VX; codeptr++ // ESTKH
                        ^codeptr = $4C;    codeptr++ // JMP abs
                        *codeptr = addrxlate=>[dest]
                        if not (*codeptr & $8000) // Unresolved address list
                            addrxlate=>[dest] = codeptr - *jitcodeptr
                        fin
                        codeptr = codeptr + 2
                        strcpy(codeptr, bytecode+i)
                        codeptr = codeptr + j + 1
                        i       = i + j
                    else
                        codeptr = codeptr + 12 + j // Flag buffer overflow
                    fin
                    A_IS_TOSL = FALSE
                    break
                // DROP,DROP2,DUP,DIVMOD,ADDI,SUBI,ANDI,ORI                ; 30 32 34 36 38 3A 3C 3E
                is $30
                    //puts("DROP")
                    VX++ //^codeptr = $E8;   codeptr++ // INX
                    A_IS_TOSL = FALSE
                    break
                is $32
                    //puts("DROP2")
                    //^codeptr = $E8;   codeptr++ // INX
                    //^codeptr = $E8;   codeptr++ // INX
                    VX = VX + 2
                    A_IS_TOSL = FALSE
                    break
                is $34
                    //puts("DUP")
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    else
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    VX-- //^codeptr = $CA;      codeptr++ // DEX
                    ^codeptr = $B4;      codeptr++ // LDY zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $94;      codeptr++ // STY zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $A0;      codeptr++ // LDY #imm
                    ^codeptr = $00;      codeptr++ // $00
                    //^codeptr = $B5;      codeptr++ // LDA zp,X
                    //^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    //^codeptr = $95;      codeptr++ // STA zp,X
                    //^codeptr = $D0+VX;   codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    break
                is $36
                    //puts("DIVMOD")
                    //
                    // Should never happen
                    //
                    break
                is $38
                    i++
                    //puts("ADDI $"); putb(^(bytecode+i))
                    if not A_IS_TOSL
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $18;    codeptr++ // CLC
                    ^codeptr = $69;    codeptr++ // ADC #imm
                    ^codeptr = ^(bytecode+i); codeptr++
                    ^codeptr = $90;    codeptr++ // BCC rel
                    ^codeptr = $02;    codeptr++ // +2
                    ^codeptr = $F6;    codeptr++ // INC zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    break
                is $3A
                    i++
                    //puts("SUBI $"); putb(^(bytecode+i))
                    if not A_IS_TOSL
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $38;    codeptr++ // SEC
                    ^codeptr = $E9;    codeptr++ // SBC #imm
                    ^codeptr = ^(bytecode+i); codeptr++
                    ^codeptr = $B0;    codeptr++ // BCS rel
                    ^codeptr = $02;    codeptr++ // +2
                    ^codeptr = $D6;    codeptr++ // DEC zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    break
                is $3C
                    i++
                    //puts("ANDI $"); putb(^(bytecode+i))
                    if not A_IS_TOSL
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $29;    codeptr++ // AND #imm
                    ^codeptr = ^(bytecode+i); codeptr++
                    ^codeptr = $94;    codeptr++ // STY zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    break
                is $3E
                    i++
                    //puts("ORI $"); putb(^(bytecode+i))
                    if not A_IS_TOSL
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $09;    codeptr++ // ORA #imm
                    ^codeptr = ^(bytecode+i); codeptr++
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    break
                // ISEQ,ISNE,ISGT,ISLT,ISGE,ISLE,BRFLS,BRTRU               ; 40 42 44 46 48 4A 4C 4E
                is $40
                    //puts("ISEQ")
                    if not A_IS_TOSL
                        ^codeptr = $B5;      codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX;   codeptr++ // ESTKL
                    fin
                    ^codeptr = $D5;      codeptr++ // CMP zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $D0;      codeptr++ // BNE rel
                    ^codeptr = $07;      codeptr++ // +7
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $D5;      codeptr++ // CMP zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $D0;      codeptr++ // BNE rel
                    ^codeptr = $01;      codeptr++ // +1                    
                    ^codeptr = $88;      codeptr++ // DEY
                    ^codeptr = $98;      codeptr++ // TYA
                    ^codeptr = $94;      codeptr++ // STY zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $A0;      codeptr++ // LDY #imm
                    ^codeptr = $00;      codeptr++ // $00
                    VX++ //^codeptr = $E8;      codeptr++ // INX
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    break
                is $42
                    //puts("ISNE")
                    if not A_IS_TOSL
                        ^codeptr = $B5;      codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX;   codeptr++ // ESTKL
                    fin
                    ^codeptr = $D5;      codeptr++ // CMP zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $D0;      codeptr++ // BNE rel
                    ^codeptr = $06;      codeptr++ // +6
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $D5;      codeptr++ // CMP zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $F0;      codeptr++ // BEQ rel
                    ^codeptr = $01;      codeptr++ // +1                    
                    ^codeptr = $88;      codeptr++ // DEY
                    ^codeptr = $98;      codeptr++ // TYA
                    ^codeptr = $94;      codeptr++ // STY zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $A0;      codeptr++ // LDY #imm
                    ^codeptr = $00;      codeptr++ // $00
                    VX++ //^codeptr = $E8;      codeptr++ // INX
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    break
                is $44
                    //puts("ISGT")
                    if not A_IS_TOSL
                        ^codeptr = $B5;      codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX;   codeptr++ // ESTKL
                    fin
                    ^codeptr = $D5;      codeptr++ // CMP zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $F5;      codeptr++ // SBC zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $50;      codeptr++ // BVC rel
                    ^codeptr = $02;      codeptr++ // +2
                    ^codeptr = $49;      codeptr++ // EOR #imm
                    ^codeptr = $80;      codeptr++ // $80
                    ^codeptr = $10;      codeptr++ // BPL rel
                    ^codeptr = $01;      codeptr++ // +1                    
                    ^codeptr = $88;      codeptr++ // DEY
                    ^codeptr = $98;      codeptr++ // TYA
                    ^codeptr = $94;      codeptr++ // STY zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $A0;      codeptr++ // LDY #imm
                    ^codeptr = $00;      codeptr++ // $00
                    VX++ //^codeptr = $E8;      codeptr++ // INX
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    break
                is $46
                    //puts("ISLT")
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $D5;      codeptr++ // CMP zp,X
                    ^codeptr = $D0+VX;   codeptr++ // ESTKL
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $F5;      codeptr++ // SBC zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $50;      codeptr++ // BVC rel
                    ^codeptr = $02;      codeptr++ // +2
                    ^codeptr = $49;      codeptr++ // EOR #imm
                    ^codeptr = $80;      codeptr++ // $80
                    ^codeptr = $10;      codeptr++ // BPL rel
                    ^codeptr = $01;      codeptr++ // +1                    
                    ^codeptr = $88;      codeptr++ // DEY
                    ^codeptr = $98;      codeptr++ // TYA
                    ^codeptr = $94;      codeptr++ // STY zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $A0;      codeptr++ // LDY #imm
                    ^codeptr = $00;      codeptr++ // $00
                    VX++ //^codeptr = $E8;      codeptr++ // INX
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    break
                is $48
                    //puts("ISGE")
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $D5;      codeptr++ // CMP zp,X
                    ^codeptr = $D0+VX;   codeptr++ // ESTKL
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $F5;      codeptr++ // SBC zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $50;      codeptr++ // BVC rel
                    ^codeptr = $02;      codeptr++ // +2
                    ^codeptr = $49;      codeptr++ // EOR #imm
                    ^codeptr = $80;      codeptr++ // $80
                    ^codeptr = $30;      codeptr++ // BMI rel
                    ^codeptr = $01;      codeptr++ // +1                    
                    ^codeptr = $88;      codeptr++ // DEY
                    ^codeptr = $98;      codeptr++ // TYA
                    ^codeptr = $94;      codeptr++ // STY zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $A0;      codeptr++ // LDY #imm
                    ^codeptr = $00;      codeptr++ // $00
                    VX++ //^codeptr = $E8;      codeptr++ // INX
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    break
                is $4A
                    //puts("ISLE")
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $D5;      codeptr++ // CMP zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $F5;      codeptr++ // SBC zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $50;      codeptr++ // BVC rel
                    ^codeptr = $02;      codeptr++ // +2
                    ^codeptr = $49;      codeptr++ // EOR #imm
                    ^codeptr = $80;      codeptr++ // $80
                    ^codeptr = $30;      codeptr++ // BMI rel
                    ^codeptr = $01;      codeptr++ // +1                    
                    ^codeptr = $88;      codeptr++ // DEY
                    ^codeptr = $98;      codeptr++ // TYA
                    ^codeptr = $94;      codeptr++ // STY zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $A0;      codeptr++ // LDY #imm
                    ^codeptr = $00;      codeptr++ // $00
                    VX++ //^codeptr = $E8;      codeptr++ // INX
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    break
                is $4C
                    i++
                    dest = i + *(bytecode+i)
                    i++
                    //puts("BRFLS "); puti(dest)
                    //VX++ //^codeptr = $E8;      codeptr++ // INX
                    codeptr, VX = resolveX(codeptr, VX + 1)
                    if not A_IS_TOSL
                        ^codeptr = $B5;      codeptr++ // LDA zp,X
                        ^codeptr = $D0-1+VX; codeptr++ // ESTKL-1
                    fin
                    ^codeptr = $15;      codeptr++ // ORA zp,X
                    ^codeptr = $C0-1+VX; codeptr++ // ESTKH-1
                    ^codeptr = $D0;      codeptr++ // BNE rel
                    ^codeptr = $03;      codeptr++ // +3
                    ^codeptr = $4C;      codeptr++ // JMP abs
                    *codeptr = addrxlate=>[dest]
                    if not (*codeptr & $8000) // Unresolved address list
                        addrxlate=>[dest] = codeptr - *jitcodeptr
                    fin
                    codeptr  = codeptr + 2
                    A_IS_TOSL = FALSE
                    break
                is $4E
                    i++
                    dest = i + *(bytecode+i)
                    i++
                    //puts("BRTRU "); puti(dest)
                    //VX++ //^codeptr = $E8;      codeptr++ // INX
                    codeptr, VX = resolveX(codeptr, VX + 1)
                    if not A_IS_TOSL
                        ^codeptr = $B5;      codeptr++ // LDA zp,X
                        ^codeptr = $D0-1+VX; codeptr++ // ESTKL-1
                    fin
                    ^codeptr = $15;      codeptr++ // ORA zp,X
                    ^codeptr = $C0-1+VX; codeptr++ // ESTKH-1
                    ^codeptr = $F0;      codeptr++ // BEQ rel
                    ^codeptr = $03;      codeptr++ // +3
                    ^codeptr = $4C;      codeptr++ // JMP abs
                    *codeptr = addrxlate=>[dest]
                    if not (*codeptr & $8000) // Unresolved address list
                        addrxlate=>[dest] = codeptr - *jitcodeptr
                    fin
                    codeptr  = codeptr + 2
                    A_IS_TOSL = FALSE
                    break
                // BRNCH,SEL,CALL,ICAL,ENTER,LEAVE,RET,CFFB                ; 50 52 54 56 58 5A 5C 5E
                is $50
                    i++
                    dest = i + *(bytecode+i)
                    i++
                    //puts("BRNCH "); puti(dest)
                    codeptr, VX = resolveX(codeptr, VX)
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $4C; codeptr++ // JMP abs
                    *codeptr = addrxlate=>[dest]
                    if not (*codeptr & $8000) // Unresolved address list
                        addrxlate=>[dest] = codeptr - *jitcodeptr
                    fin
                    codeptr = codeptr + 2
                    A_IS_TOSL = FALSE
                    break
                is $52
                    i++
                    case = i + *(bytecode+i)
                    i++
                    //puts("SEL "); puti(case); putln
                    j = ^(bytecode+case)
                    dest = codeptr + 8 + case * 11)
                    if isule(dest, codemax)
                        ^(bytecode+case) = $FE // Flag as NOP
                        case++
                        if not A_IS_TOSL
                            ^codeptr = $B5;    codeptr++ // LDA zp,X
                            ^codeptr = $D0+VX; codeptr++ // ESTKL
                        fin
                        ^codeptr = $B4;    codeptr++ // LDY zp,X
                        ^codeptr = $C0+VX; codeptr++ // ESTKH
                        //VX++ //^codeptr = $E8;    codeptr++ // INX
                        codeptr, VX = resolveX(codeptr, VX + 1)
                        repeat
                            //puts("    $"); puth(*(bytecode+case))
                            ^codeptr = $C9; codeptr++ // CMP #imm
                            ^codeptr = ^(bytecode+case); codeptr++
                            ^codeptr = $D0; codeptr++ // BNE rel
                            ^codeptr = $09; codeptr++ // +9
                            ^codeptr = $C0; codeptr++ // CPY #imm
                            ^codeptr = ^(bytecode+case+1); codeptr++
                            ^codeptr = $D0; codeptr++ // BNE rel
                            ^codeptr = $05; codeptr++ // +5
                            *(bytecode+case) = $FEFE
                            case = case + 2
                            dest = case + *(bytecode+case)
                            //puts("-->"); puti(dest); putln
                            ^codeptr = $A0; codeptr++ // LDY #imm
                            ^codeptr = $00; codeptr++ // $00
                            ^codeptr = $4C; codeptr++ // JMP abs
                            *codeptr = addrxlate=>[dest]
                            if not (*codeptr & $8000) // Unresolved address list
                                addrxlate=>[dest] = codeptr - *jitcodeptr
                            fin
                            codeptr          = codeptr + 2                            
                            *(bytecode+case) = $FEFE
                            case = case + 2
                            j--
                        until not j
                        ^codeptr = $A0; codeptr++ // LDY #imm
                        ^codeptr = $00; codeptr++ // $00
                        ^codeptr = $4C; codeptr++ // JMP abs
                        *codeptr = addrxlate=>[case]
                        if not (*codeptr & $8000) // Unresolved address list
                            addrxlate=>[case] = codeptr - *jitcodeptr
                        fin
                        codeptr = codeptr + 2
                    else
                        codeptr = dest
                    fin
                    A_IS_TOSL = FALSE
                    break
                is $54
                    i++
                    //puts("CALL $"); puth(*(bytecode+i))
                    //
                    // Call address
                    //
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    codeptr, VX = resolveX(codeptr, VX)
                    ^codeptr = $20; codeptr++ // JSR abs
                    *codeptr = *(bytecode+i); codeptr = codeptr + 2
                    ^codeptr = $A0; codeptr++ // LDY #imm
                    ^codeptr = $00; codeptr++ // $00
                    A_IS_TOSL = FALSE
                    i++
                    break
                is $56
                    //puts("ICAL")
                    //
                    // Pull address off stack
                    //
                    if not A_IS_TOSL
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $85;    codeptr++ // STA zp
                    ^codeptr = $E7;    codeptr++ // $E7:TMPL                           
                    ^codeptr = $B5;    codeptr++ // LDA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $85;    codeptr++ // STA zp
                    ^codeptr = $E8;    codeptr++ // $E8:TMPH                           
                    //VX++ //^codeptr = $E8;    codeptr++ // INX
                    codeptr, VX = resolveX(codeptr, VX + 1)
                    //
                    // Call through TMP
                    //
                    ^codeptr = $20; codeptr++ // JSR abs
                    ^codeptr = $E6; codeptr++ // <JMPTMP
                    ^codeptr = $00; codeptr++ // >JMPTMP
                    ^codeptr = $A0; codeptr++ // LDY #imm
                    ^codeptr = $00; codeptr++ // $00
                    A_IS_TOSL = FALSE
                   break
                is $5A
                    i++
                    //puts("LEAVE "); puti(^(bytecode+i))
                    //
                    // Call into VM
                    //
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    codeptr, VX = resolveX(codeptr, VX)
                    ^codeptr = $20;  codeptr++ // JSR INTERP
                    *codeptr = $3D0; codeptr = codeptr + 2
                    ^codeptr = $5A;  codeptr++ // LEAVE CODE
                    ^codeptr = ^(bytecode+i); codeptr++ // LEAVE OPERAND
                    A_IS_TOSL = FALSE
                    break
                is $5C
                    //puts("RET")
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    codeptr, VX = resolveX(codeptr, VX)
                    ^codeptr = $60; codeptr++ // RTS
                    A_IS_TOSL = FALSE
                   break
                is $5E
                    i++
                    //puts("CFFB $FF"); putb(^(bytecode+i))
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    VX-- //^codeptr = $CA;    codeptr++ // DEX
                    ^codeptr = $A9;    codeptr++ // LDA #imm
                    ^codeptr = $FF;    codeptr++ // $FF
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $A9;    codeptr++ // LDA #imm
                    ^codeptr = ^(bytecode+i); codeptr++
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    break
                // LB,LW,LLB,LLW,LAB,LAW,DLB,DLW                           ; 60 62 64 66 68 6A 6C 6E
                is $60
                    //puts("LB")
                    if not A_IS_TOSL
                        ^codeptr = $B5;      codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX;   codeptr++ // ESTKL
                    fin
                    ^codeptr = $95;      codeptr++ // STA zp,X
                    ^codeptr = $C0-1+VX; codeptr++ // ESTKH-1
                    ^codeptr = $A1;      codeptr++ // LDA (zp,X)
                    ^codeptr = $C0-1+VX; codeptr++ // ESTKH-1
                    ^codeptr = $94;      codeptr++ // STY zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    //^codeptr = $95;      codeptr++ // STA zp,X
                    //^codeptr = $D0+VX;   codeptr++ // ESTKL                    
                    A_IS_TOSL = TOSL_DIRTY
                    break
                is $62
                    //puts("LW")
                    if not A_IS_TOSL
                        ^codeptr = $B5;      codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX;   codeptr++ // ESTKL
                    fin
                    ^codeptr = $95;      codeptr++ // STA zp,X
                    ^codeptr = $C0-1+VX; codeptr++ // ESTKH-1
                    ^codeptr = $A1;      codeptr++ // LDA (zp,X)
                    ^codeptr = $C0-1+VX; codeptr++ // ESTKH-1
                    ^codeptr = $95;      codeptr++ // STA zp,X
                    ^codeptr = $D0+VX;   codeptr++ // ESTKL                    
                    ^codeptr = $F6;      codeptr++ // INC zp,X
                    ^codeptr = $C0-1+VX; codeptr++ // ESTKH-1
                    ^codeptr = $D0;      codeptr++ // BNE rel
                    ^codeptr = $02;      codeptr++ // +2                    
                    ^codeptr = $F6;      codeptr++ // INC zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $A1;      codeptr++ // LDA (zp,X)
                    ^codeptr = $C0-1+VX; codeptr++ // ESTKH-1
                    ^codeptr = $95;      codeptr++ // STA zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    A_IS_TOSL = FALSE
                    break
                is $64
                    i++
                    //puts("LLB "); puti(^(bytecode+i))
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    VX-- //^codeptr = $CA;    codeptr++ // DEX
                    if ^(bytecode+i) <> 0
                        ^codeptr = $A0;    codeptr++ // LDY #imm
                        ^codeptr = ^(bytecode+i); codeptr++
                    fin
                    ^codeptr = $B1;    codeptr++ // LDA (zp),Y
                    ^codeptr = $E0;    codeptr++ // IFP
                    if ^(bytecode+i) <> 0
                        ^codeptr = $A0;    codeptr++ // LDY #imm
                        ^codeptr = $00;    codeptr++ // $00
                    fin
                    ^codeptr = $94;    codeptr++ // STY zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    break
                is $66
                    i++
                    //puts("LLW "); puti(^(bytecode+i))
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    VX-- //^codeptr = $CA;    codeptr++ // DEX
                    if ^(bytecode+i) <> 0
                        ^codeptr = $A0;    codeptr++ // LDY #imm
                        ^codeptr = ^(bytecode+i); codeptr++
                    fin
                    ^codeptr = $B1;    codeptr++ // LDA (zp),Y
                    ^codeptr = $E0;    codeptr++ // IFP
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $D0+VX; codeptr++ // ESTKL
                    ^codeptr = $C8;    codeptr++ // INY
                    ^codeptr = $B1;    codeptr++ // LDA (zp),Y
                    ^codeptr = $E0;    codeptr++ // IFP
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    if ^(bytecode+i) <> 0
                        ^codeptr = $A0;    codeptr++ // LDY #imm
                        ^codeptr = $00;    codeptr++ // $00
                    else
                        ^codeptr = $88;    codeptr++ // DEY
                    fin
                    A_IS_TOSL = FALSE
                    break
                is $68
                    i++
                    //puts("LAB $"); puth(*(bytecode+i))
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    VX-- //^codeptr = $CA;    codeptr++ // DEX
                    ^codeptr = $AD;    codeptr++ // LDA abs
                    *codeptr = *(bytecode+i); codeptr = codeptr + 2
                    ^codeptr = $94;    codeptr++ // STY zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    i++
                    break
                is $6A
                    i++
                    //puts("LAW $"); puth(*(bytecode+i))
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    VX-- //^codeptr = $CA;    codeptr++ // DEX
                    ^codeptr = $AD;    codeptr++ // LDA abs
                    *codeptr = *(bytecode+i)+1; codeptr = codeptr + 2
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $AD;    codeptr++ // LDA abs
                    *codeptr = *(bytecode+i);   codeptr = codeptr + 2
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    i++
                    break
                is $6C
                    i++
                    //puts("DLB "); puti(^(bytecode+i))
                    if not A_IS_TOSL
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                        A_IS_TOSL = TOSL_CLEAN
                    fin
                    if ^(bytecode+i) <> 0
                        ^codeptr = $A0;    codeptr++ // LDY #imm
                        ^codeptr = ^(bytecode+i); codeptr++
                    fin
                    ^codeptr = $91;    codeptr++ // STA (zp),Y
                    ^codeptr = $E0;    codeptr++ // IFP
                    if ^(bytecode+i) <> 0
                        ^codeptr = $A0;    codeptr++ // LDY #imm
                        ^codeptr = $00;    codeptr++ // $00
                    fin
                    break
                is $6E
                    i++
                    //puts("DLW "); puti(^(bytecode+i))
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    if ^(bytecode+i) <> 0
                        ^codeptr = $A0;    codeptr++ // LDY #imm
                        ^codeptr = ^(bytecode+i)+1; codeptr++
                    else
                        ^codeptr = $C8;    codeptr++ // INY
                    fin
                    ^codeptr = $B5;    codeptr++ // LDA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $91;    codeptr++ // STA (zp),Y
                    ^codeptr = $E0;    codeptr++ // IFP
                    ^codeptr = $88;    codeptr++ // DEY
                    ^codeptr = $B5;    codeptr++ // LDA zp,X
                    ^codeptr = $D0+VX; codeptr++ // ESTKL
                    ^codeptr = $91;    codeptr++ // STA (zp),Y
                    ^codeptr = $E0;    codeptr++ // IFP
                    if ^(bytecode+i) <> 0                    
                        ^codeptr = $A0;    codeptr++ // LDY #imm
                        ^codeptr = $00;    codeptr++ // $00
                    fin
                    A_IS_TOSL = TOSL_CLEAN
                    break
                // SB,SW,SLB,SLW,SAB,SAW,DAB,DAW                           ; 70 72 74 76 78 7A 7C 7E
                is $70
                    //puts("SB")
                    if not A_IS_TOSL
                        ^codeptr = $B5;      codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX;   codeptr++ // ESTKL
                    fin
                    ^codeptr = $95;      codeptr++ // STA zp,X
                    ^codeptr = $C0-1+VX; codeptr++ // ESTKH-1
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1                    
                    ^codeptr = $81;      codeptr++ // STA (zp,X)
                    ^codeptr = $C0-1+VX; codeptr++ // ESTKH-1
                    //^codeptr = $E8;      codeptr++ // INX
                    //^codeptr = $E8;      codeptr++ // INX
                    VX = VX + 2
                    A_IS_TOSL = FALSE
                    break
                is $72
                    //puts("SW")
                    if not A_IS_TOSL
                        ^codeptr = $B5;      codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX;   codeptr++ // ESTKL
                    fin
                    ^codeptr = $95;      codeptr++ // STA zp,X
                    ^codeptr = $C0-1+VX; codeptr++ // ESTKH-1
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1                    
                    ^codeptr = $81;      codeptr++ // STA (zp,X)
                    ^codeptr = $C0-1+VX; codeptr++ // ESTKH-1
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1                    
                    ^codeptr = $F6;      codeptr++ // INC zp,X
                    ^codeptr = $C0-1+VX; codeptr++ // ESTKH-1
                    ^codeptr = $D0;      codeptr++ // BNE rel
                    ^codeptr = $02;      codeptr++ // +2                    
                    ^codeptr = $F6;      codeptr++ // INC zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $81;      codeptr++ // STA (zp,X)
                    ^codeptr = $C0-1+VX; codeptr++ // ESTKH-1
                    //^codeptr = $E8;      codeptr++ // INX
                    //^codeptr = $E8;      codeptr++ // INX
                    VX = VX + 2
                    A_IS_TOSL = FALSE
                    break
                is $74
                    i++
                    //puts("SLB "); puti(^(bytecode+i))
                    if not A_IS_TOSL
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    if ^(bytecode+i) <> 0                    
                        ^codeptr = $A0;    codeptr++ // LDY #imm
                        ^codeptr = ^(bytecode+i); codeptr++
                    fin
                    ^codeptr = $91;    codeptr++ // STA (zp),Y
                    ^codeptr = $E0;    codeptr++ // IFP
                    if ^(bytecode+i) <> 0                    
                        ^codeptr = $A0;    codeptr++ // LDY #imm
                        ^codeptr = $00;    codeptr++ // $00
                    fin
                    VX++ //^codeptr = $E8;    codeptr++ // INX
                    A_IS_TOSL = FALSE
                    break
                is $76
                    i++
                    //puts("SLW "); puti(^(bytecode+i))
                    if not A_IS_TOSL
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    if ^(bytecode+i) <> 0                    
                        ^codeptr = $A0;    codeptr++ // LDY #imm
                        ^codeptr = ^(bytecode+i); codeptr++
                    fin
                    ^codeptr = $91;    codeptr++ // STA (zp),Y
                    ^codeptr = $E0;    codeptr++ // IFP
                    ^codeptr = $C8;    codeptr++ // INY
                    ^codeptr = $B5;    codeptr++ // LDA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $91;    codeptr++ // STA (zp),Y
                    ^codeptr = $E0;    codeptr++ // IFP
                    if ^(bytecode+i) <> 0                    
                        ^codeptr = $A0;    codeptr++ // LDY #imm
                        ^codeptr = $00;    codeptr++ // $00
                    else
                        ^codeptr = $88;    codeptr++ // DEY
                    fin
                    VX++ //^codeptr = $E8;    codeptr++ // INX
                    A_IS_TOSL = FALSE
                    break
                is $78
                    i++
                    //puts("SAB $"); puth(*(bytecode+i))
                    if not A_IS_TOSL
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $8D;    codeptr++ // STA abs
                    *codeptr = *(bytecode+i); codeptr = codeptr + 2
                    VX++ //^codeptr = $E8;    codeptr++ // INX
                    A_IS_TOSL = FALSE
                    i++
                    break
                is $7A
                    i++
                    //puts("SAW $"); puth(*(bytecode+i))
                    if not A_IS_TOSL
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $8D;    codeptr++ // STA abs
                    *codeptr = *(bytecode+i);   codeptr = codeptr + 2
                    ^codeptr = $B5;    codeptr++ // LDA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $8D;    codeptr++ // STA abs
                    *codeptr = *(bytecode+i)+1; codeptr = codeptr + 2
                    VX++ //^codeptr = $E8;    codeptr++ // INX
                    A_IS_TOSL = FALSE
                    i++
                    break
                is $7C
                    i++
                    //puts("DAB $"); puth(*(bytecode+i))
                    if not A_IS_TOSL
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                        A_IS_TOSL = TOSL_CLEAN
                    fin
                    ^codeptr = $8D; codeptr++ // STA abs
                    *codeptr = *(bytecode+i); codeptr = codeptr + 2
                    i++
                    break
                is $7E
                    i++
                    //puts("DAW $"); puth(*(bytecode+i))
                    if not A_IS_TOSL
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                        A_IS_TOSL = TOSL_CLEAN
                    fin
                    ^codeptr = $8D;    codeptr++ // STA abs
                    *codeptr = *(bytecode+i);   codeptr = codeptr + 2
                    ^codeptr = $B4;    codeptr++ // LDY zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $8C;    codeptr++ // STY abs
                    *codeptr = *(bytecode+i)+1; codeptr = codeptr + 2
                    ^codeptr = $A0;    codeptr++ // LDY #imm
                    ^codeptr = $00;    codeptr++ // $00
                    i++
                    break
                // LNOT,ADD,SUB,MUL,DIV,MOD,INCR,DECR                      ; 80 82 84 86 88 8A 8C 8E
                is $80
                    //puts("NOT")
                    if not A_IS_TOSL
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $15;    codeptr++ // ORA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $F0;    codeptr++ // BEQ rel
                    ^codeptr = $02;    codeptr++ // +2
                    ^codeptr = $A9;    codeptr++ // LDA #imm
                    ^codeptr = $FF;    codeptr++ // $FF
                    ^codeptr = $49;    codeptr++ // EOR #imm
                    ^codeptr = $FF;    codeptr++ // $FF
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    break
                is $82
                    //puts("ADD")
                    if not A_IS_TOSL
                        ^codeptr = $B5;      codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX;   codeptr++ // ESTKL
                    fin
                    ^codeptr = $18;      codeptr++ // CLC
                    ^codeptr = $75;      codeptr++ // ADC zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $95;      codeptr++ // STA zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $75;      codeptr++ // ADC zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $95;      codeptr++ // STA zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    VX++ //^codeptr = $E8;      codeptr++ // INX
                    A_IS_TOSL = FALSE
                    break
                is $84
                    //puts("SUB")
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $38;      codeptr++ // SEC
                    ^codeptr = $F5;      codeptr++ // SBC zp,X
                    ^codeptr = $D0+VX;   codeptr++ // ESTKL
                    ^codeptr = $95;      codeptr++ // STA zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $F5;      codeptr++ // SBC zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $95;      codeptr++ // STA zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    VX++ //^codeptr = $E8;      codeptr++ // INX
                    A_IS_TOSL = FALSE
                    break
                is $86 // MUL
                is $88 // DIV
                is $8A // MOD
                is $9A // SHL
                is $9C // SHR
                    //puts("MUL,DIV,MOD,SHL,SHR")
                    //  when opcode
                    //        is $86
                    //            puts("MUL")
                    //        is $88
                    //            puts("DIV")
                    //        is $8A
                    //            puts("MOD")
                    //         is $9A
                    //            puts("SHL")
                    //        is $9C
                    //            puts("SHR")
                    //  wend
                    //
                    // Call into VM
                    //
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    codeptr, VX = resolveX(codeptr, VX)
                    ^codeptr = $20;  codeptr++ // JSR INTERP
                    *codeptr = $3D0; codeptr = codeptr + 2
                    ^codeptr = opcode;  codeptr++ // OPCODE
                    ^codeptr = $C0;  codeptr++ // NATV CODE
                    ^codeptr = $A0;  codeptr++ // LDY #imm
                    ^codeptr = $00;  codeptr++ // $00
                    A_IS_TOSL = FALSE
                     break
               is $8C
                    //puts("INCR")
                    if not A_IS_TOSL
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $18;    codeptr++ // CLC
                    ^codeptr = $69;    codeptr++ // ADC #imm
                    ^codeptr = $01;    codeptr++ // $01
                    ^codeptr = $90;    codeptr++ // BCC rel
                    ^codeptr = $02;    codeptr++ // +2
                    ^codeptr = $F6;    codeptr++ // INC zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    break
                is $8E
                    //puts("DECR")
                    if not A_IS_TOSL
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $38;    codeptr++ // SEC
                    ^codeptr = $E9;    codeptr++ // SBC #imm
                    ^codeptr = $01;    codeptr++ // $01
                    ^codeptr = $B0;    codeptr++ // BCS rel
                    ^codeptr = $02;    codeptr++ // +2
                    ^codeptr = $D6;    codeptr++ // DEC zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    break
                // NEG,COMP,BAND,IOR,XOR,SHL,SHR,IDXW                      ; 90 92 94 96 98 9A 9C 9E
                is $90
                    //puts("NEG")
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $98;    codeptr++ // TYA -> LDA #$00
                    ^codeptr = $38;    codeptr++ // SEC
                    ^codeptr = $F5;    codeptr++ // SBC zp,X
                    ^codeptr = $D0+VX; codeptr++ // ESTKL
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $D0+VX; codeptr++ // ESTKL
                    ^codeptr = $98;    codeptr++ // TYA -> LDA #00
                    ^codeptr = $F5;    codeptr++ // SBC zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    A_IS_TOSL = FALSE
                    break
                is $92
                    //puts("COMP")
                    if not A_IS_TOSL
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $49;    codeptr++ // EOR #imm
                    ^codeptr = $FF;    codeptr++ // $FF
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $D0+VX; codeptr++ // ESTKL
                    ^codeptr = $B5;    codeptr++ // LDA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $49;    codeptr++ // EOR #imm
                    ^codeptr = $FF;    codeptr++ // $FF
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    A_IS_TOSL = FALSE
                    break
                is $94
                    //puts("AND")
                    if not A_IS_TOSL
                        ^codeptr = $B5;      codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX;   codeptr++ // ESTKL
                    fin
                    ^codeptr = $35;      codeptr++ // AND zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $95;      codeptr++ // STA zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $35;      codeptr++ // AND zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $95;      codeptr++ // STA zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    VX++ //^codeptr = $E8;      codeptr++ // INX
                    A_IS_TOSL = FALSE
                    break
                is $96
                    //puts("OR")
                    if not A_IS_TOSL
                        ^codeptr = $B5;      codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX;   codeptr++ // ESTKL
                    fin
                    ^codeptr = $15;      codeptr++ // ORA zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $95;      codeptr++ // STA zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $15;      codeptr++ // ORA zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $95;      codeptr++ // STA zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    VX++ //^codeptr = $E8;      codeptr++ // INX
                    A_IS_TOSL = FALSE
                    break
                is $98
                    //puts("XOR")
                    if not A_IS_TOSL
                        ^codeptr = $B5;      codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX;   codeptr++ // ESTKL
                    fin
                    ^codeptr = $55;      codeptr++ // EOR zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $95;      codeptr++ // STA zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $55;      codeptr++ // EOR zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $95;      codeptr++ // STA zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    VX++ //^codeptr = $E8;      codeptr++ // INX
                    A_IS_TOSL = FALSE
                    break
                is $9E
                    //puts("IDXW")
                    if not A_IS_TOSL
                        ^codeptr = $B5;      codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX;   codeptr++ // ESTKL
                    fin
                    ^codeptr = $0A;      codeptr++ // ASL
                    ^codeptr = $36;      codeptr++ // ROL zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $18;      codeptr++ // CLC
                    ^codeptr = $75;      codeptr++ // ADC zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $95;      codeptr++ // STA zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $75;      codeptr++ // ADC zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $95;      codeptr++ // STA zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    VX++ //^codeptr = $E8;      codeptr++ // INX
                    A_IS_TOSL = FALSE
                    break
                // BRGT,BRLT,INCBRLE,ADDBRLE,DECBRGE,SUBBRGE,BRAND,BROR    ; A0 A2 A4 A6 A8 AA AC AE
                is $A0
                    i++
                    dest = i + *(bytecode+i)
                    //puts("BRGT "); puti(dest)
                    i++
                    codeptr, VX = resolveX(codeptr, VX)
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $D5;      codeptr++ // CMP zp,X
                    ^codeptr = $D0+VX;   codeptr++ // ESTKL
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $F5;      codeptr++ // SBC zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $50;      codeptr++ // BVC rel
                    ^codeptr = $02;      codeptr++ // +2
                    ^codeptr = $49;      codeptr++ // EOR #imm
                    ^codeptr = $80;      codeptr++ // $80
                    ^codeptr = $10;      codeptr++ // BPL rel
                    ^codeptr = $05;      codeptr++ // +5                    
                    ^codeptr = $E8;      codeptr++ // INX
                    ^codeptr = $E8;      codeptr++ // INX
                    ^codeptr = $4C;      codeptr++ // JMP abs
                    *codeptr = addrxlate=>[dest]
                    if not (*codeptr & $8000) // Unresolved address list
                        addrxlate=>[dest] = codeptr - *jitcodeptr
                    fin
                    codeptr  = codeptr + 2
                    A_IS_TOSL = FALSE
                    break
                is $A2
                    i++
                    dest = i + *(bytecode+i)
                    //puts("BRLT "); puti(dest)
                    i++
                    codeptr, VX = resolveX(codeptr, VX)
                    if not A_IS_TOSL
                        ^codeptr = $B5;      codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX;   codeptr++ // ESTKL
                    else
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $D5;      codeptr++ // CMP zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $F5;      codeptr++ // SBC zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $50;      codeptr++ // BVC rel
                    ^codeptr = $02;      codeptr++ // +2
                    ^codeptr = $49;      codeptr++ // EOR #imm
                    ^codeptr = $80;      codeptr++ // $80
                    ^codeptr = $10;      codeptr++ // BPL rel
                    ^codeptr = $05;      codeptr++ // +5                    
                    ^codeptr = $E8;      codeptr++ // INX
                    ^codeptr = $E8;      codeptr++ // INX
                    ^codeptr = $4C;      codeptr++ // JMP abs
                    *codeptr = addrxlate=>[dest]
                    if not (*codeptr & $8000) // Unresolved address list
                        addrxlate=>[dest] = codeptr - *jitcodeptr
                    fin
                    codeptr  = codeptr + 2
                    A_IS_TOSL = FALSE
                    break
                is $A4
                    i++
                    dest = i + *(bytecode+i)
                    //puts("INCBRLE "); puti(dest)
                    i++
                    //
                    // INCR
                    //
                    if not A_IS_TOSL
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $18;    codeptr++ // CLC
                    ^codeptr = $69;    codeptr++ // ADC #imm
                    ^codeptr = $01;    codeptr++ // $01
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $D0+VX; codeptr++ // ESTKL
                    ^codeptr = $90;    codeptr++ // BCC rel
                    ^codeptr = $02;    codeptr++ // +2
                    ^codeptr = $F6;    codeptr++ // INC zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    //
                    // BRLE
                    //
                    codeptr, VX = resolveX(codeptr, VX)
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $D5;      codeptr++ // CMP zp,X
                    ^codeptr = $D0+VX;   codeptr++ // ESTKL
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $F5;      codeptr++ // SBC zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $50;      codeptr++ // BVC rel
                    ^codeptr = $02;      codeptr++ // +2
                    ^codeptr = $49;      codeptr++ // EOR #imm
                    ^codeptr = $80;      codeptr++ // $80
                    ^codeptr = $30;      codeptr++ // BMI rel
                    ^codeptr = $03;      codeptr++ // +3                    
                    ^codeptr = $4C;      codeptr++ // JMP abs
                    *codeptr = addrxlate=>[dest]
                    if not (*codeptr & $8000) // Unresolved address list
                        addrxlate=>[dest] = codeptr - *jitcodeptr
                    fin
                    codeptr  = codeptr + 2
                    ^codeptr = $E8;      codeptr++ // INX
                    ^codeptr = $E8;      codeptr++ // INX
                    A_IS_TOSL = FALSE
                    break
                is $A6
                    i++
                    dest = i + *(bytecode+i)
                    //puts("ADDBRLE "); puti(dest)
                    i++
                    //
                    // ADD
                    //
                    if not A_IS_TOSL
                        ^codeptr = $B5;      codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX;   codeptr++ // ESTKL
                    fin
                    ^codeptr = $18;      codeptr++ // CLC
                    ^codeptr = $75;      codeptr++ // ADC zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $95;      codeptr++ // STA zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $75;      codeptr++ // ADC zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $95;      codeptr++ // STA zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    //VX++ //^codeptr = $E8;      codeptr++ // INX
                    //
                    // BRLE
                    //
                    codeptr, VX = resolveX(codeptr, VX + 1)
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $D5;      codeptr++ // CMP zp,X
                    ^codeptr = $D0+VX;   codeptr++ // ESTKL
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $F5;      codeptr++ // SBC zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $50;      codeptr++ // BVC rel
                    ^codeptr = $02;      codeptr++ // +2
                    ^codeptr = $49;      codeptr++ // EOR #imm
                    ^codeptr = $80;      codeptr++ // $80
                    ^codeptr = $30;      codeptr++ // BMI rel
                    ^codeptr = $03;      codeptr++ // +3                    
                    ^codeptr = $4C;      codeptr++ // JMP abs
                    *codeptr = addrxlate=>[dest]
                    if not (*codeptr & $8000) // Unresolved address list
                        addrxlate=>[dest] = codeptr - *jitcodeptr
                    fin
                    codeptr  = codeptr + 2
                    ^codeptr = $E8;      codeptr++ // INX
                    ^codeptr = $E8;      codeptr++ // INX
                    A_IS_TOSL = FALSE
                    break
                is $A8
                    i++
                    dest = i + *(bytecode+i)
                    //puts("DECBRGE "); puti(dest)
                    i++
                    //
                    // DECR
                    //
                    if not A_IS_TOSL
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $38;    codeptr++ // SEC
                    ^codeptr = $E9;    codeptr++ // SBC #imm
                    ^codeptr = $01;    codeptr++ // $01
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $D0+VX; codeptr++ // ESTKL
                    ^codeptr = $B0;    codeptr++ // BCS rel
                    ^codeptr = $02;    codeptr++ // +2
                    ^codeptr = $D6;    codeptr++ // DEC zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    //
                    // BRGE
                    //
                    codeptr, VX = resolveX(codeptr, VX)
                    //^codeptr = $B5;      codeptr++ // LDA zp,X
                    //^codeptr = $D0+VX;   codeptr++ // ESTKL
                    ^codeptr = $D5;      codeptr++ // CMP zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $F5;      codeptr++ // SBC zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $50;      codeptr++ // BVC rel
                    ^codeptr = $02;      codeptr++ // +2
                    ^codeptr = $49;      codeptr++ // EOR #imm
                    ^codeptr = $80;      codeptr++ // $80
                    ^codeptr = $30;      codeptr++ // BMI rel
                    ^codeptr = $03;      codeptr++ // +3                    
                    ^codeptr = $4C;      codeptr++ // JMP abs
                    *codeptr = addrxlate=>[dest]
                    if not (*codeptr & $8000) // Unresolved address list
                        addrxlate=>[dest] = codeptr - *jitcodeptr
                    fin
                    codeptr  = codeptr + 2
                    ^codeptr = $E8;      codeptr++ // INX
                    ^codeptr = $E8;      codeptr++ // INX
                    A_IS_TOSL = FALSE
                    break
                is $AA
                    i++
                    dest = i + *(bytecode+i)
                    //puts("SUBBRGE "); puti(dest)
                    i++
                    //
                    // SUB
                    //
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $38;      codeptr++ // SEC
                    ^codeptr = $F5;      codeptr++ // SBC zp,X
                    ^codeptr = $D0+VX;   codeptr++ // ESTKL
                    ^codeptr = $95;      codeptr++ // STA zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $F5;      codeptr++ // SBC zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $95;      codeptr++ // STA zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    //VX++ //^codeptr = $E8;      codeptr++ // INX
                    //
                    // BRGE
                    //
                    codeptr, VX = resolveX(codeptr, VX + 1)
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $D0+VX;   codeptr++ // ESTKL
                    ^codeptr = $D5;      codeptr++ // CMP zp,X
                    ^codeptr = $D0+1+VX; codeptr++ // ESTKL+1
                    ^codeptr = $B5;      codeptr++ // LDA zp,X
                    ^codeptr = $C0+VX;   codeptr++ // ESTKH
                    ^codeptr = $F5;      codeptr++ // SBC zp,X
                    ^codeptr = $C0+1+VX; codeptr++ // ESTKH+1
                    ^codeptr = $50;      codeptr++ // BVC rel
                    ^codeptr = $02;      codeptr++ // +2
                    ^codeptr = $49;      codeptr++ // EOR #imm
                    ^codeptr = $80;      codeptr++ // $80
                    ^codeptr = $30;      codeptr++ // BMI rel
                    ^codeptr = $03;      codeptr++ // +3                    
                    ^codeptr = $4C;      codeptr++ // JMP abs
                    *codeptr = addrxlate=>[dest]
                    if not (*codeptr & $8000) // Unresolved address list
                        addrxlate=>[dest] = codeptr - *jitcodeptr
                    fin
                    codeptr  = codeptr + 2
                    ^codeptr = $E8;      codeptr++ // INX
                    ^codeptr = $E8;      codeptr++ // INX
                    A_IS_TOSL = FALSE
                    break
                is $AC
                    i++
                    dest = i + *(bytecode+i)
                    i++
                    //puts("BRAND "); puti(dest)
                    codeptr, VX = resolveX(codeptr, VX)
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    else
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $15;    codeptr++ // ORA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $D0;    codeptr++ // BNE rel
                    ^codeptr = $03;    codeptr++ // +3
                    ^codeptr = $4C;    codeptr++ // JMP abs
                    *codeptr = addrxlate=>[dest]
                    if not (*codeptr & $8000) // Unresolved address list
                        addrxlate=>[dest] = codeptr - *jitcodeptr
                    fin
                    codeptr  = codeptr + 2
                    ^codeptr = $E8;    codeptr++ // INX VX++ ???
                    A_IS_TOSL = FALSE
                    break
                is $AE
                    i++
                    dest = i + *(bytecode+i)
                    i++
                    //puts("BROR "); puti(dest)
                    codeptr, VX = resolveX(codeptr, VX)
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    else
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $15;    codeptr++ // ORA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $F0;    codeptr++ // BEQ rel
                    ^codeptr = $03;    codeptr++ // +3
                    ^codeptr = $4C;    codeptr++ // JMP abs
                    *codeptr = addrxlate=>[dest]
                    if not (*codeptr & $8000) // Unresolved address list
                        addrxlate=>[dest] = codeptr - *jitcodeptr
                    fin
                    codeptr  = codeptr + 2
                    ^codeptr = $E8;    codeptr++ // INX // VX++ ???
                    A_IS_TOSL = FALSE
                    break
                // ADDLB,ADDLW,ADDAB,ADDAW,IDXLB,IDXLW,IDXAB,IDXAW         ; B0 B2 B4 B6 B8 BA BC BE
                is $B0
                    i++
                    //puts("ADDLB "); puti(^(bytecode+i))
                    if not A_IS_TOSL
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    if ^(bytecode+i) <> 0                    
                        ^codeptr = $A0;    codeptr++ // LDY #imm
                        ^codeptr = ^(bytecode+i); codeptr++
                    fin
                    ^codeptr = $18;    codeptr++ // CLC
                    ^codeptr = $71;    codeptr++ // ADC (zp),Y
                    ^codeptr = $E0;    codeptr++ // IFP
                    ^codeptr = $90;    codeptr++ // BCC rel
                    ^codeptr = $02;    codeptr++ // +2
                    ^codeptr = $F6;    codeptr++ // INC zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    if ^(bytecode+i) <> 0                    
                        ^codeptr = $A0;    codeptr++ // LDY #imm
                        ^codeptr = $00;    codeptr++ // $00
                    fin
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    break
                is $B2
                    i++
                    //puts("ADDLW "); puti(^(bytecode+i))
                    if not A_IS_TOSL
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    if ^(bytecode+i) <> 0                    
                        ^codeptr = $A0;    codeptr++ // LDY #imm
                        ^codeptr = ^(bytecode+i); codeptr++
                    fin
                    ^codeptr = $18;    codeptr++ // CLC
                    ^codeptr = $71;    codeptr++ // ADC (zp),Y
                    ^codeptr = $E0;    codeptr++ // IFP
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $D0+VX; codeptr++ // ESTKL
                    ^codeptr = $B5;    codeptr++ // LDA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $C8;    codeptr++ // INY
                    ^codeptr = $71;    codeptr++ // ADC (zp),Y
                    ^codeptr = $E0;    codeptr++ // IFP
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    if ^(bytecode+i) <> 0                    
                        ^codeptr = $A0;    codeptr++ // LDY #imm
                        ^codeptr = $00;    codeptr++ // $00
                    else
                        ^codeptr = $88;    codeptr++ // DEY
                    fin
                    A_IS_TOSL = FALSE
                    break
                is $B4
                    i++
                    //puts("ADDAB $"); puth(*(bytecode+i))
                    if not A_IS_TOSL
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $18;    codeptr++ // CLC
                    ^codeptr = $6D;    codeptr++ // ADC abs
                    *codeptr = *(bytecode+i); codeptr = codeptr + 2
                    ^codeptr = $90;    codeptr++ // BCC rel
                    ^codeptr = $02;    codeptr++ // +2
                    ^codeptr = $F6;    codeptr++ // INC zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    //^codeptr = $95;    codeptr++ // STA zp,X
                    //^codeptr = $D0+VX; codeptr++ // ESTKL
                    A_IS_TOSL = TOSL_DIRTY
                    i++
                    break
                is $B6
                    i++
                    //puts("ADDAW $"); puth(*(bytecode+i))
                    if not A_IS_TOSL
                        ^codeptr = $B5;    codeptr++ // LDA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $18;    codeptr++ // CLC
                    ^codeptr = $6D;    codeptr++ // ADC abs
                    *codeptr = *(bytecode+i);   codeptr = codeptr + 2
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $D0+VX; codeptr++ // ESTKL
                    ^codeptr = $B5;    codeptr++ // LDA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $6D;    codeptr++ // ADC abs
                    *codeptr = *(bytecode+i)+1; codeptr = codeptr + 2
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    A_IS_TOSL = FALSE
                    i++
                    break
                is $B8
                    i++
                    //puts("IDXLB "); puti(^(bytecode+i))
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    if ^(bytecode+i) <> 0                    
                        ^codeptr = $A0;    codeptr++ // LDY #imm
                        ^codeptr = ^(bytecode+i); codeptr++
                    fin
                    ^codeptr = $B1;    codeptr++ // LDA (zp),Y
                    ^codeptr = $E0;    codeptr++ // IFP
                    if ^(bytecode+i) <> 0                    
                        ^codeptr = $A0;    codeptr++ // LDY #imm
                        ^codeptr = $00;    codeptr++ // $00
                    fin
                    ^codeptr = $0A;    codeptr++ // ASL
                    ^codeptr = $90;    codeptr++ // BCC rel
                    ^codeptr = $02;    codeptr++ // +2
                    ^codeptr = $C8;    codeptr++ // INY
                    ^codeptr = $18;    codeptr++ // CLC
                    ^codeptr = $75;    codeptr++ // ADC zp,X  
                    ^codeptr = $D0+VX; codeptr++ // ESTKL
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $D0+VX; codeptr++ // ESTKL
                    ^codeptr = $98;    codeptr++ // TYA
                    ^codeptr = $75;    codeptr++ // ADC zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $A0;    codeptr++ // LDY #imm
                    ^codeptr = $00;    codeptr++ // $00
                    A_IS_TOSL = FALSE
                    break
                is $BA
                    i++
                    //puts("IDXLW "); puti(^(bytecode+i))
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    if ^(bytecode+i) <> 0                    
                        ^codeptr = $A0;    codeptr++ // LDY #imm
                        ^codeptr = ^(bytecode+i); codeptr++
                    fin
                    ^codeptr = $B1;    codeptr++ // LDA (zp),Y
                    ^codeptr = $E0;    codeptr++ // IFP
                    ^codeptr = $0A;    codeptr++ // ASL
                    ^codeptr = $85;    codeptr++ // STA zp
                    ^codeptr = $E7;    codeptr++ // $E7:TMPL                           
                    ^codeptr = $C8;    codeptr++ // INY
                    ^codeptr = $B1;    codeptr++ // LDA (zp),Y
                    ^codeptr = $E0;    codeptr++ // IFP
                    ^codeptr = $2A;    codeptr++ // ROL
                    ^codeptr = $A8;    codeptr++ // TAY
                    ^codeptr = $A5;    codeptr++ // LDA zp
                    ^codeptr = $E7;    codeptr++ // $E7:TMPL                           
                    ^codeptr = $18;    codeptr++ // CLC
                    ^codeptr = $75;    codeptr++ // ADC zp,X
                    ^codeptr = $D0+VX; codeptr++ // ESTKL
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $D0+VX; codeptr++ // ESTKL
                    ^codeptr = $98;    codeptr++ // TYA
                    ^codeptr = $75;    codeptr++ // ADC zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $A0;    codeptr++ // LDY #imm
                    ^codeptr = $00;    codeptr++ // $00
                    A_IS_TOSL = FALSE
                    break
                is $BC
                    i++
                    //puts("IDXAB $"); puth(*(bytecode+i))
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $AD;    codeptr++ // LDA abs
                    *codeptr = *(bytecode+i); codeptr = codeptr + 2
                    ^codeptr = $0A;    codeptr++ // ASL
                    ^codeptr = $90;    codeptr++ // BCC rel
                    ^codeptr = $02;    codeptr++ // +2
                    ^codeptr = $C8;    codeptr++ // INY
                    ^codeptr = $18;    codeptr++ // CLC
                    ^codeptr = $75;    codeptr++ // ADC zp,X
                    ^codeptr = $D0+VX; codeptr++ // ESTKL
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $D0+VX; codeptr++ // ESTKL
                    ^codeptr = $98;    codeptr++ // TYA
                    ^codeptr = $75;    codeptr++ // ADC zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $A0;    codeptr++ // LDY #imm
                    ^codeptr = $00;    codeptr++ // $00
                    A_IS_TOSL = FALSE
                    i++
                    break
                is $BE
                    i++
                    //puts("IDXAW $"); puth(*(bytecode+i))
                    if A_IS_TOSL & TOSL_DIRTY
                        ^codeptr = $95;    codeptr++ // STA zp,X
                        ^codeptr = $D0+VX; codeptr++ // ESTKL
                    fin
                    ^codeptr = $AD;    codeptr++ // LDA abs
                    *codeptr = *(bytecode+i);   codeptr = codeptr + 2
                    ^codeptr = $0A;    codeptr++ // ASL
                    ^codeptr = $85;    codeptr++ // STA zp
                    ^codeptr = $E7;    codeptr++ // $E7:TMPL                           
                    ^codeptr = $AD;    codeptr++ // LDA abs
                    *codeptr = *(bytecode+i)+1; codeptr = codeptr + 2
                    ^codeptr = $2A;    codeptr++ // ROL
                    ^codeptr = $A8;    codeptr++ // TAY
                    ^codeptr = $A5;    codeptr++ // LDA zp
                    ^codeptr = $E7;    codeptr++ // $E7:TMPL                           
                    ^codeptr = $18;    codeptr++ // CLC
                    ^codeptr = $75;    codeptr++ // ADC zp,X
                    ^codeptr = $D0+VX; codeptr++ // ESTKL
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $D0+VX; codeptr++ // ESTKL
                    ^codeptr = $98;    codeptr++ // TYA
                    ^codeptr = $75;    codeptr++ // ADC zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $95;    codeptr++ // STA zp,X
                    ^codeptr = $C0+VX; codeptr++ // ESTKH
                    ^codeptr = $A0;    codeptr++ // LDY #imm
                    ^codeptr = $00;    codeptr++ // $00
                    A_IS_TOSL = FALSE
                    i++
                    break
                is $FE // NOPed out earlier by SELect
                    break
                otherwise
                    //putc('$'); puth(^(bytecode+i))
            wend
        fin
        //putln
        i++
        if i >= defptr->bytecodesize
            //
            // Done compiling. Update DEF entry with JMP to compiled code
            //
            defptr->interpjsr  = $4C // JMP
            defptr=>interpaddr = *jitcodeptr
            *jitcodeptr        = codeptr
            //
            // Free working bufffers
            //
            //heaprelease(addrxlate)
            //puts("Done compiling: $"); puth(defptr=>interpaddr); putln
            //getc
            return
        fin
        //getc
    loop
    //
    // If we got here. we ran out of code buffer space. Overwrite interpreter
    // entrypoint with standard bytecode interpreter
    //
    defptr=>interpaddr = interpentry
    //
    // Free working bufffers
    //
    //heaprelease(addrxlate)
    //puts("Ran out of code buffer\n")
    //getc
end
//
// Install JIT compiler
//
if *jitcomp
    puts("JIT compiler already installed!\n")
    return 0
fin
puts("Installing JIT compiler\n")
*jitcomp = @compiler
return modkeep
done
